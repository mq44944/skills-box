# 软件架构模式

![](http://i.imgur.com/3GFrpZ5.jpg)

## 目录

## 简介

对程序员来说很常见一种情况是在没有合理的程序架构时就开始编程，没有一个清晰的和定义好的架构的时候，大多数开发者和架构师通常会使用标准式的传统分层架构模式（也被称为多层架构）—通过将源码模块分割为几个不同的层到不同的包中。不幸的是，这种编码方式会导致一系列没有组织性的代码模块，这些模块缺乏明确的规则、职责和同其他模块之间的关联。这通常被称为架构大泥球。

应用程序缺乏合理的架构一般会导致程序过度耦合、容易被破坏、难以应对变化，同时很难有个清晰的版本或者方向性。这样的结果是，如果你没有充分理解程序系统里每个组件和模块，就很难定义这个程序的结构特征。有关于程序的部署和维护的基本问题都难以回答，比如：程序架构是什么规模?应用程序有什么性能特点?应用程序有多容易应对变化?应用程序的部署特点是什么?架构是如何反应的?

架构模式帮助你定义应用程序的基本特征和行为。例如，些架构模式会让程序自己自然⽽而然地朝着具有良 好伸缩性的方向发展，⽽而其他架构模式会让程序朝着高度灵活的方向发展。知道了这些特点，了解架构模式 的优点和缺点是非常必要的，它帮助我们选择个适合自己特定的业务需求和目标的的程序。

作为个架构师,你必须证明你的架构模式的决策是正确的,特别是当需要选择一个特定的体系结构模式或方法 的时候。这本迷你书的目的就是给你⾜足够的信息让你去做出正确的架构决策。

## 第一章 分层架构

分层架构是一种很常⻅见的架构模式，它也叫N层架构。这种架构是大多数Jave EE应用的实际标准，因此很多 的架构师，设计师，还有程序员都知道它。许多传统IT公司的组织架构和分层模式十分的相似。所以它很自 然的成为大多数应用的架构模式。

### 模式分析

分层架构模式里的组件被分成几个平行的层次，每一层都代表了应用的一个功能(展示逻辑或者业务逻辑)。 尽管分层架构没有规定自⾝身要分成几层几种，大多数的结构都分成四个层次:展示层，业务层，持久层，和数 据库层。如表1-1，有时候，业务层和持久层会合并成单独的一个业务层，尤其是持久层的逻辑绑定在业务层 的组件当中。因此，有一些小的应用可能只有3层，一些有着更复杂的业务的大应用可能有5层或者更多的分 层。

分层架构中的每一层都着特定的角色和职能。举个例子，展示层负责处理所有的界面展示以及交互逻辑，业 务层负责处理请求对应的业务。架构里的层次是具体工作的高度抽象，它们都是为了实现某种特定的业务请 求。比如说展示层并不需要关⼼心怎样得到用户数据，它只需在屏幕上以特定的格式展示信息。业务层并不关
⼼心要展示在屏幕上的用户数据格式，也不关⼼心这些用户数据从哪里来。它只需要从持久层得到数据，执行与 数据有关的相应业务逻辑，然后把这些信息传递给展示层。

![](http://i.imgur.com/SxUxjRZ.png)

分层架构的一个突出特性是组件间关注点分离 (separation of concerns)。一个层中的组件只会处理本层的逻 辑。比如说，展示层的组件只会处理展示逻辑，业务层中的组件只会去处理业务逻辑。多亏了组件分离，让 我们更容易构造有效的角色和强⼒力的模型。这样应用变的更好开发，测试，管理和维护。

### 关键概念

注意表1-2中每一层都是封闭的。这是分层架构中非常重要的特点。这意味request必须一层一层的传递。举 个例子，从展示层传递来的请求⾸首先会传递到业务层，然后传递到持久层，最后才传递到数据层。

![](http://i.imgur.com/D7sRDmv.png)

那么为什么不允许展示层直接访问数据层呢。如果只是获得以及读取数据，展示层直接访问数据层，比穿过一层一层来得到数据来的快多了。这涉及到一个概念:层隔离。

层隔离就是说架构中的某一层的改变不会影响到其他层:这些变化的影响范围限于当前层次。如果展示层能够 直接访问持久层了，假如持久层中的SQL变化了，这对业务层和展示层都有一定的影响。这只会让应用变得 紧耦合，组件之间互相依赖。这种架构会非常的难以维护。

从另外一个方面来说，分层隔离使得层与层之间都是相互独立的，架构中的每一层的互相了解都很少。为了 说明这个概念的⽜牛逼之处，想象一个超级重构，把展示层从JSP换成JSF。假设展示层和业务层的之间的联系 保持一致，业务层不会受到重构的影响，它和展示层所使用的界面架构完全独立。

然⽽而封闭的架构层次也有不便之处，有时候也应该开放某一层。如果想往包含了一些由业务层的组件调用的 普通服务组件的架构中添加个分享服务层。在这个例子里，新建一个服务层通常是个好主意，因为从架构上来说，它限制了分享服务访问业务层(也不允许访问展示层)。如果没有隔离层，就没有任何架构来限制展示层访问普通服务，难以进行权限管理。

在这个例子中，新的服务层是处于业务层之下的，展示层不能直接访问这个服务层中的组件。但是现在业务 层还要通过服务层才能访问到持久层，这一点也不合理。这是分层架构中的老问题了，解决的办法是开放某 些层。如表1-3所示，服务层现在是开放的了。请求可以绕过这一层，直接访问这层下面的层。既然服务层 是开放的，业务层可以绕过服务层，直接访问数据持久层。这样就非常合理。

![](http://i.imgur.com/NEnLu8b.png)

开放和封闭层的概念确定了架构层和请求流之间的关系，并且给设计师和开发人员提供了必要的信息理解架 构里各种层之间的访问限制。如果随意的开放或者封闭架构里的层，整个项目可能都是紧耦合，一团糟的。以后也难以测试，维护和部署。

### 示例

为了演示分层架构是如何工作的，想象一个场景，如表1-4，用户发出了个请求要获得客户的信息。黑色的箭头是从数据库中获得用户数据的请求流，红色箭头显示用户数据的返回流的方向。在这个例子中，用户信 息由客户数据和订单数组组成(客户下的订单)。

用户界面只管接受请求以及显示客户信息。它不管怎么得到数据的，或者说得到这些数据要用到哪些数据 表。如果用户界面接到了一个查询客户信息的请求，它就会转发这个请求给用户委托(Customer Delegate)模 块。这个模块能找到业务层里对应的模块处理对应数据(约束关系)。业务层里的customer object聚合了业务 请求需要的所有信息(在这个例子里获取客户信息)。这个模块调用持久层中的 customer dao 来得到客户信 息，调用order dao来得到订单信息。这些模块会执行SQL语句，然后返回相应的数据给业务层。当 customer object收到数据以后，它就会聚合这些数据然后传递给 customer delegate,然后传递这些数据到 customer screen 展示在用户面前。

![](http://i.imgur.com/kKlpuwM.png)

从技术的角度来说，有很多的方式能够实现这些模块。比如说在Java平台中，customer screen 对应的是 (JSF) Java Server Faces ,用 bean 组件来实现 customer delegate。用本地的Spring bean或者远程的EJB3 bean 来实现业务层中的customer object。上例中的数据访问可以用简单的POJP's(Plain Old Java Objects)，或者可以用MyBatis，还可以用JDBC或者Hibernate查询。Microsoft平台上，customer    screen能
用 .NET 库的ASP模块来访问业务层中的C#模块，用ADO来实现用户和订单数据的访问模块。

我们看一下淘宝前几年的架构的例子。

![](http://i.imgur.com/R5pzfpW.png)

这是一个标准的分层的架构。每一层中又可以详细的分成更细的层，比如服务层。

![](http://i.imgur.com/M10wcT6.png)

围着着这个主架构还有一些外围的产品。比如监控和审计。

### 注意事项

分层架构是一个很可靠的架构模式。它适合大多数的应用。如果你不确定在项目中使用什么架构，分层架构 是再好不过的了。然后，从架构的角度上来说，选择这个模式还要考虑很多的东⻄西。

第一个要注意的就是 污水池反模式(architecture sinkhole anti-pattern)。 在这个模式中，请求流只是简单的 穿过层次，不留一点云彩，或者说只留下一阵⻘青烟。比如说界面层响应了一个获得数据的请求。响应层把这 个请求传递给了业务层，业务层也只是传递了这个请求到持久层，持久层对数据库做简单的SQL查询获得用户的数据。这个数据按照原理返回，不会有任何的二次处理，返回到界面上。

每个分层架构或多或少都可能遇到这种场景。关键在于这样的请求有多少。80-20原则可以帮助你确定架构是 否处于反污水模式。大概有百分之二十的请求仅仅是做简单的穿越，百分之八十的请求会做一些业务逻辑操 作。然而，如果这个比例反过来，大部分的请求都是仅仅穿过层，不做逻辑操作。那么开放一些架构层会比较好。不过由于缺少了层次隔离，项目会变得难以控制。

### 模式分析

下⾯面的的表⾥里分析了分层架构的各个⽅方⾯面。

#### 整体灵活性

评级:低 分析:总体灵活性是响应环境变化的能⼒力。尽管分层模式中的变化可以隔绝起来，想在这种架构中做⼀一些也改 变也是并且费时费⼒力的。分层模式的笨重以及经常出现的组件之间的紧耦合是导致灵活性降低的原因。

#### 易于部署

评级:低 分析:这取决于你怎么发布这种模式，发布程序可能⽐比较⿇麻烦，尤其是很⼤大的项目。⼀一个组件的⼩小⼩小改动可能 会影响到整个程序的发布(或者程序的⼤大部分)。发布必须是按照计划，在⾮非⼯工作时间或者周末进⾏行发布。因此,分层模式导致应⽤用发布⼀一点也不流畅，在发布上降低了灵活性。

#### 可测试性

评级:高 分析:因为组件都处于各⾃自的层次中，可以模拟其他的层，或者说直接去掉层，所以分层模式很容易测试。开发者可以单独模拟⼀一个展⽰示组件，对业务组件进⾏行隔绝测试。还可以模拟业务层来测试某个展⽰示功能。

#### 性能

评级:低 分析:尽管某些分层架构的性能表现的确不错，但是这个模式的特点导致它⽆无法带来⾼高性能。因为⼀一次业务请求要穿越所有的架构层，做了很多不必要的⼯工作。

#### 伸缩性

评级:低 分析:由于这种模式以紧密耦合的趋势在发展，规模也⽐比较⼤大，⽤用分层架构构建的程序都⽐比较难以扩展。你可 以把各个层分成单独的物理模块或者干脆把整个程序分成多个节点来扩展分层架构，但是总体的关系过于紧

密，这样很难扩展。

#### 易开发性

评级:容易 分析:在开发难度上⾯面，分层架构得到了⽐比较⾼高的分数。因为这种架构对⼤大家来说很熟悉，不难实现。⼤大部分 公司在开发项⺫⽬目的都是通过层来区分技术的，这种模式对于⼤大多数的商业项目开发来说都很合适。公司的组织架构和他们软件架构之间的联系被戏称为"Conway's law"。你可以Google⼀一下查查这个有趣的联系。

> 未完待续